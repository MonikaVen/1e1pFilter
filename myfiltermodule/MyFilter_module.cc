////////////////////////////////////////////////////////////////////////
// Class:       MyFilter
// Module Type: filter
// File:        MyFilter_module.cc
//
// Generated at Mon Oct  3 13:17:19 2016 by Lorena Escudero Sanchez using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include <memory>

#include "SimulationBase/MCParticle.h"
#include "SimulationBase/MCTruth.h"
#include "SimulationBase/MCTrajectory.h"
#include "Geometry/Geometry.h"


class MyFilter;

class MyFilter : public art::EDFilter {
public:
  explicit MyFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MyFilter(MyFilter const &) = delete;
  MyFilter(MyFilter &&) = delete;
  MyFilter & operator = (MyFilter const &) = delete;
  MyFilter & operator = (MyFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;

private:

  // Declare member data here.
  int   fInteractionType;
  float m_detectorHalfLengthX;
  float m_detectorHalfLengthY;
  float m_detectorHalfLengthZ;
  float m_coordinateOffsetX;
  float m_coordinateOffsetY;
  float m_coordinateOffsetZ;
  float m_selectedBorderX;
  float m_selectedBorderY;
  float m_selectedBorderZ;

};


MyFilter::MyFilter(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  this->reconfigure(p);
}

bool MyFilter::filter(art::Event & e)
{
  bool pass = true;

  art::Handle< std::vector< simb::MCTruth > > mct_handle;
  e.getByLabel("generator", mct_handle );
  //  e.getByLabel("corsika", mct_handle );
  //  e.getByLabel("largeant", mct_handle );

  int size = mct_handle->size();
  //std::cout << "MCT handle size = " << size << std::endl; 
  if(mct_handle.isValid() && size) {
    for(auto const& mct : (*mct_handle)) {

      if(mct.Origin() != simb::kBeamNeutrino) continue;

      //First, check interaction type
      int interaction = mct.GetNeutrino().InteractionType();
      //      std::cout << "Interaction: " << interaction << " and I want: " << fInteractionType << std::endl;
      if(interaction != fInteractionType) 
	return false;


      //Second, check in fiducial volume
      float nuVtxX = mct.GetNeutrino().Nu().Vx();                                                                      
      float nuVtxY = mct.GetNeutrino().Nu().Vy();                                                                             
      float nuVtxZ = mct.GetNeutrino().Nu().Vz(); 

      //std::cout << "nuVtxX=" << nuVtxX << " , nuVtxY = " << nuVtxY << " , nuVtxZ = " << nuVtxZ << std::endl;

      if ((nuVtxX > (m_detectorHalfLengthX - m_coordinateOffsetX - m_selectedBorderX)) || (nuVtxX < (-m_coordinateOffsetX + m_selectedBorderX)) ||
	  (nuVtxY > (m_detectorHalfLengthY - m_coordinateOffsetY - m_selectedBorderY)) || (nuVtxY < (-m_coordinateOffsetY + m_selectedBorderY)) ||
	  (nuVtxZ > (m_detectorHalfLengthZ - m_coordinateOffsetZ - m_selectedBorderZ)) || (nuVtxZ < (-m_coordinateOffsetZ + m_selectedBorderZ)) )
	return false;

      //Third, get number of particles                                                                                            
      const int particles = mct.NParticles();                                                                             
      //std::cout << "particles = " << particles << std::endl;                                                          
      int n_neutrino(0), n_muon(0), n_proton(0), n_piplus(0), n_pizero(0), n_neutrons(0), n_target(0), n_hadronic(0), n_others(0);                      
      for (int i= 0; i < particles; i++)                                                                               
        {      
	  if(mct.GetParticle(i).PdgCode()==14)
	    n_neutrino++;
	  else if(mct.GetParticle(i).PdgCode()==13)
	    n_muon++;
	  else if(mct.GetParticle(i).PdgCode()==2212)
	    n_proton++;
	  else if(mct.GetParticle(i).PdgCode()==2112)
	    n_neutrons++;
	  else if(mct.GetParticle(i).PdgCode()==211)
	    n_piplus++;
	  else if(mct.GetParticle(i).PdgCode()==111)
	    n_pizero++;
	  else if(mct.GetParticle(i).PdgCode()>=1000000000)
	    n_target++;
	  else if(mct.GetParticle(i).PdgCode()>=2000000000)
	    n_hadronic++;
	  else 
	    n_others++;
	    
	  //	  std::cout << "MC Particle PDG = " << mct.GetParticle(i).PdgCode() << std::endl;                                 
      }
      //  std::cout << "NU: " << n_neutrino << " MU: " << n_muon  << " P: " << n_proton << " N: " << n_neutrons << " PIPLUS: " << n_piplus << " PIZERO: " << n_pizero << " TARGET: " << n_target << " HADRONIC: " << n_hadronic << " OTHER: " << n_others << std::endl; 

      //Finally, cuts depending on number of particles
      /*      if((fInteractionType == 1001) &&
	 ((n_neutrino !=1) ||
	  (n_muon != 1) ||
	  (n_proton != 1) ||
	  (n_piplus != 0) ||
	  (n_pizero != 0) ||
	  (n_others != 0)))
	return false;

      if((fInteractionType == 1003) &&
	 ((n_neutrino !=1) ||
	  (n_muon != 1) ||
	  (n_proton != 1) ||
	  (n_piplus != 1) ||
	  (n_pizero != 0) ||
	  (n_others != 0)))
	return false;

      if((fInteractionType == 1004) &&
	 ((n_neutrino !=1) ||
	  (n_muon != 1) ||
	  (n_proton != 1) ||
	  (n_piplus != 0) ||
	  (n_pizero != 1) ||
	  (n_others != 0)))
	return false;
      */
    }
  }

  return pass;
}

void MyFilter::beginJob()
{
  // Implementation of optional member function here.
}

void MyFilter::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  fInteractionType = p.get<int>("InteractionType");
  m_detectorHalfLengthX = p.get<float>("DetectorHalfLengthX");
  m_detectorHalfLengthY = p.get<float>("DetectorHalfLengthY");
  m_detectorHalfLengthZ = p.get<float>("DetectorHalfLengthZ");
  m_coordinateOffsetX = p.get<float>("CoordinateOffsetX");
  m_coordinateOffsetY = p.get<float>("CoordinateOffsetY");
  m_coordinateOffsetZ = p.get<float>("CoordinateOffsetZ");
  m_selectedBorderX = p.get<float>("SelectedBorderX");
  m_selectedBorderY = p.get<float>("SelectedBorderY");
  m_selectedBorderZ = p.get<float>("SelectedBorderZ");

}

DEFINE_ART_MODULE(MyFilter)
