////////////////////////////////////////////////////////////////////////
// Class:       MyFilter
// Module Type: filter
// File:        MyFilter_module.cc
//
// Generated at Mon Oct  3 13:17:19 2016 by Lorena Escudero Sanchez using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>


//LORENA
#include "lardata/Utilities/AssociationUtil.h"

#include "art/Framework/Services/Optional/TFileService.h"

//#include "nusimdata/SimulationBase/MCNeutrino.h"
#include "nusimdata/SimulationBase/MCParticle.h"

#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Hit.h"

#include "lardataobj/MCBase/MCShower.h"

#include "larcore/Geometry/GeometryCore.h"
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/CryostatGeo.h"
#include "larcore/Geometry/PlaneGeo.h"
#include "larcore/Geometry/OpDetGeo.h"
#include "larcore/Geometry/WireGeo.h"
#include "larcore/Geometry/TPCGeo.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/Utilities/GeometryUtilities.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"

//from larpandora
#include "cetlib/exception.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Principal/Handle.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "lardataobj/AnalysisBase/CosmicTag.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Seed.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/SpacePoint.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "lardataobj/RecoBase/Wire.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "larcoreobj/SimpleTypesAndConstants/RawTypes.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"

#include "lardataobj/Simulation/SimChannel.h"

namespace anab {class CosmicTag;}
namespace pandora {class ParticleFlowObject; class Vertex;}
namespace recob {class Cluster; class Hit; class PFParticle; class Seed; class Shower; class SpacePoint; class Track; class Vertex; class Wire;}
namespace sim {class SimChannel; class TrackIDE;}
namespace simb {class MCParticle; class MCTruth;}



class MyFilter;

class MyFilter : public art::EDFilter {
public:
  explicit MyFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MyFilter(MyFilter const &) = delete;
  MyFilter(MyFilter &&) = delete;
  MyFilter & operator = (MyFilter const &) = delete;
  MyFilter & operator = (MyFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;

private:

  // Declare member data here.

};


MyFilter::MyFilter(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
}

bool MyFilter::filter(art::Event & e)
{
  // Implementation of required member function here.
  bool pass = false;

  art::Handle< std::vector<simb::MCParticle> > theParticles;
  e.getByLabel("largeant", theParticles);
  art::FindOneP<simb::MCTruth> mcTruthAssns(theParticles, e, "largeant");

  for (unsigned int n = 0; n < theParticles->size(); ++n)
    {
      art::Ptr<simb::MCTruth> mcTruth = mcTruthAssns.at(n);

      if (mcTruth->Origin() != simb::kBeamNeutrino) continue;
      if (mcTruth->Origin() == simb::kBeamNeutrino)
	{
	  //	  const simb::MCNeutrino neutrino(mcTruth->GetNeutrino());	  
	  // if(neutrino.InteractionType() == 1004)
	  //  pass = true;
	}
    }  
  return pass;
}

void MyFilter::beginJob()
{
  // Implementation of optional member function here.
}

void MyFilter::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(MyFilter)
