////////////////////////////////////////////////////////////////////////
// Class:       MyFilter
// Module Type: filter
// File:        MyFilter_module.cc
//
// Generated at Mon Oct  3 13:17:19 2016 by Lorena Escudero Sanchez using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include <memory>

#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/RawData/TriggerData.h"


class MyFilter;

class MyFilter : public art::EDFilter {
public:
  explicit MyFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MyFilter(MyFilter const &) = delete;
  MyFilter(MyFilter &&) = delete;
  MyFilter & operator = (MyFilter const &) = delete;
  MyFilter & operator = (MyFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;

private:

  // Declare member data here.

};


MyFilter::MyFilter(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
}

bool MyFilter::filter(art::Event & e)
{
  // Implementation of required member function here.
  bool pass = false;

  art::Handle< std::vector< simb::MCTruth > > mct_handle;
  e.getByLabel("largeant", mct_handle );
  if(mct_handle.isValid() && mct_handle->size()) {
    for(auto const& mct : (*mct_handle)) {

      if(mct.Origin() != simb::kBeamNeutrino) continue;
      //      const simb::MCNeutrino neutrino(
      if(mct.GetNeutrino().InteractionType() == 1004) 
	//      if(neutrino.InteractionType() == 1004) 
	pass = true;

      std::cout << "InteractionType() = " << mct.GetNeutrino().InteractionType() << std::endl;

    }
  }

  /* art::Handle< std::vector<simb::MCParticle> > theParticles;
  e.getByLabel("largeant", theParticles);
  art::FindOneP<simb::MCTruth> mcTruthAssns(theParticles, e, "largeant");

  for (unsigned int n = 0; n < theParticles->size(); ++n)
    {
      art::Ptr<simb::MCTruth> mcTruth = mcTruthAssns.at(n);

      if (mcTruth->Origin() != simb::kBeamNeutrino) continue;
      if (mcTruth->Origin() == simb::kBeamNeutrino)
	{
	  //	  const simb::MCNeutrino neutrino(mcTruth->GetNeutrino());	  
	  // if(neutrino.InteractionType() == 1004)
	  //  pass = true;
	}
	}*/  
  return pass;
}

void MyFilter::beginJob()
{
  // Implementation of optional member function here.
}

void MyFilter::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(MyPi0Filter)
