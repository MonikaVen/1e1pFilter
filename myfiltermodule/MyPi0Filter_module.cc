////////////////////////////////////////////////////////////////////////
// Class:       MyFilter
// Module Type: filter
// File:        MyFilter_module.cc
//
// Generated at Mon Oct  3 13:17:19 2016 by Lorena Escudero Sanchez using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include <memory>

#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/RawData/TriggerData.h"


class MyPi0Filter;

class MyPi0Filter : public art::EDFilter {
public:
  explicit MyPi0Filter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MyPi0Filter(MyPi0Filter const &) = delete;
  MyPi0Filter(MyPi0Filter &&) = delete;
  MyPi0Filter & operator = (MyPi0Filter const &) = delete;
  MyPi0Filter & operator = (MyPi0Filter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;

private:

  // Declare member data here.

};


MyPi0Filter::MyPi0Filter(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
}

bool MyPi0Filter::filter(art::Event & e)
{
  bool pass = false;

  art::Handle< std::vector< simb::MCTruth > > mct_handle;
  e.getByLabel("generator", mct_handle );
  //  e.getByLabel("largeant", mct_handle );

  if(mct_handle.isValid() && mct_handle->size()) {
    for(auto const& mct : (*mct_handle)) {

      if(mct.Origin() != simb::kBeamNeutrino) continue;

      if(mct.GetNeutrino().InteractionType() == 1004) 
	pass = true;

      //std::cout << "Interaction: " << mct.GetNeutrino().InteractionType() << std::endl;

    }
  }

  return pass;
}

void MyPi0Filter::beginJob()
{
  // Implementation of optional member function here.
}

void MyPi0Filter::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(MyPi0Filter)
