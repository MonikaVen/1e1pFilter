////////////////////////////////////////////////////////////////////////
// Class:       PandoraLEEAnalyzer
// Module Type: analyzer
// File:        PandoraLEEAnalyzer_module.cc
//
// Generated at Thu Jun 23 00:24:52 2016 by Lorena Escudero Sanchez using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////


#include <fstream>

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "larsim/MCCheater/BackTracker.h"


//uncomment the lines below as you use these objects

#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/MCBase/MCShower.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Utilities/InputTag.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "larpandora/LArPandoraInterface/LArPandoraHelper.h"
#include "larcoreobj/SummaryData/POTSummary.h"

#include "TTree.h"
#include "TFile.h"
#include "TH1F.h"
#include "THStack.h"
#include "TVector3.h"

#include "TEfficiency.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include "ElectronEventSelectionAlg.h"
#include "larpandora/LArPandoraInterface/LArPandoraHelper.h"

#include "SpaceChargeMicroBooNE.h"


using namespace lar_pandora;


namespace lee {
class PandoraLEEAnalyzer;
}

class lee::PandoraLEEAnalyzer : public art::EDAnalyzer {
public:
  explicit PandoraLEEAnalyzer(fhicl::ParameterSet const & pset);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  virtual ~PandoraLEEAnalyzer();

  // Plugins should not be copied or assigned.
  PandoraLEEAnalyzer(PandoraLEEAnalyzer const &) = delete;
  PandoraLEEAnalyzer(PandoraLEEAnalyzer &&) = delete;
  PandoraLEEAnalyzer & operator = (PandoraLEEAnalyzer const &) = delete;
  PandoraLEEAnalyzer & operator = (PandoraLEEAnalyzer &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void endSubRun(const art::SubRun& sr);
  void reconfigure(fhicl::ParameterSet const &pset) override;

private:

  lee::ElectronEventSelectionAlg fElectronEventSelectionAlg;

  TFile * myTFile;
  TTree * myTTree;
  TTree * myPOTTTree;

  bool m_printDebug;
  double m_fidvolXstart;
  double m_fidvolXend;

  double m_fidvolYstart;
  double m_fidvolYend;

  double m_fidvolZstart;
  double m_fidvolZend;

  double m_trackLength;

  const int k_cosmic = 1;
  const int k_nu_e = 2;
  const int k_nu_mu = 3;
  const int k_nc = 4;
  const int k_dirt = 5;
  const int k_data = 6;
  double _energy;
  double _track_dir_z;
  double _track_length;
  int _true_nu_is_fiducial;
  double _nu_energy;

  int _n_tracks;
  int _n_showers;

  double _vx;
  double _vy;
  double _vz;

  double _true_vx;
  double _true_vy;
  double _true_vz;

  double _true_vx_sce;
  double _true_vy_sce;
  double _true_vz_sce;

  int _nu_matched_tracks;
  int _nu_matched_showers;

  int _category;
  int _run;
  int _subrun;
  int _event;
  int _n_candidates;
  int _n_true_nu;
  int _run_sr;
  int _subrun_sr;
  int _n_matched;
  double _pot;
  int _event_passed;
  double _distance;

  int _flash_passed;
  int _track_passed;
  int _shower_passed;

  std::vector< double > _shower_dir_x;
  std::vector< double > _shower_dir_y;
  std::vector< double > _shower_dir_z;

  std::vector< double > _shower_theta;
  std::vector< double > _shower_phi;

  std::vector< int > _nu_daughters_pdg;
  std::vector< double > _nu_daughters_E;

  double _reco_px;
  double _reco_py;
  double _reco_pz;
  double _true_px;
  double _true_py;
  double _true_pz;

  double distance(double a[3], double b[3]);
  bool is_dirt(double x[3]) const;
  void measure_energy(size_t ipf, const art::Event & evt, double & energy);
  size_t choose_candidate(std::vector<size_t> & candidates, const art::Event & evt);
  void get_daughter_tracks( std::vector < size_t > pf_ids, const art::Event & evt, std::vector< art::Ptr<recob::Track> > &tracks);
  void get_daughter_showers( std::vector < size_t > pf_ids, const art::Event & evt, std::vector< art::Ptr<recob::Shower> > &showers);
  double trackEnergy(const art::Ptr<recob::Track>& track, const art::Event & evt);
  int correct_direction(size_t pfp_id,const art::Event & evt);
  TVector3 average_position(std::vector<art::Ptr < recob::SpacePoint > > &spcpnts);
  void clear();

  art::Ptr<recob::Track> get_longest_track(std::vector< art::Ptr<recob::Track> > &tracks);
  art::Ptr<recob::Shower> get_most_energetic_shower(std::vector< art::Ptr<recob::Shower> > &showers);

};


lee::PandoraLEEAnalyzer::PandoraLEEAnalyzer(fhicl::ParameterSet const & pset)
  :
  EDAnalyzer(pset)  // ,
// More initializers here.
{

  //create output tree
  art::ServiceHandle<art::TFileService> tfs;
  // myTFile = new TFile("PandoraLEEAnalyzerOutput.root", "RECREATE");
  myTTree = tfs->make<TTree>("pandoratree", "PandoraAnalysis Tree");

  myPOTTTree = tfs->make<TTree>("pot", "POT Tree");

  myTTree->Branch("category",  &_category, "category/i");
  myTTree->Branch("E",  &_energy, "E/d");
  myTTree->Branch("trk_dir_z",  &_track_dir_z, "trk_dir_z/d");
  myTTree->Branch("trk_len",  &_track_length, "trk_len/d");
  myTTree->Branch("n_tracks",  &_n_tracks, "n_tracks/i");
  myTTree->Branch("n_showers",  &_n_showers, "n_showers/i");
  myTTree->Branch("vx",  &_vx, "vx/d");
  myTTree->Branch("vy",  &_vy, "vy/d");
  myTTree->Branch("vz",  &_vz, "vz/d");

  myTTree->Branch("true_vx",  &_true_vx, "true_vx/d");
  myTTree->Branch("true_vy",  &_true_vy, "true_vy/d");
  myTTree->Branch("true_vz",  &_true_vz, "true_vz/d");

  myTTree->Branch("true_vx_sce",  &_true_vx_sce, "true_vx_sce/d");
  myTTree->Branch("true_vy_sce",  &_true_vy_sce, "true_vx_sce/d");
  myTTree->Branch("true_vz_sce",  &_true_vz_sce, "true_vx_sce/d");

  myTTree->Branch("nu_E",  &_nu_energy, "nu_E/d");
  myTTree->Branch("passed",  &_event_passed, "passed/I");
  myTTree->Branch("n_candidates", &_n_candidates, "n_candidates/i");
  myTTree->Branch("n_true_nu", &_n_true_nu, "n_true_nu/i");
  myTTree->Branch("distance", &_distance, "distance/d");
  myTTree->Branch("true_nu_is_fiducial", &_true_nu_is_fiducial, "true_nu_is_fiducial/I");

  myTTree->Branch("n_matched", &_n_matched, "n_matched/i");
  myTTree->Branch("nu_matched_tracks", &_nu_matched_tracks, "nu_matched_tracks/i");
  myTTree->Branch("nu_matched_showers", &_nu_matched_showers, "nu_matched_showers/i");

  myTTree->Branch("nu_daughters_pdg",  "std::vector< int >", &_nu_daughters_pdg);
  myTTree->Branch("nu_daughters_E",  "std::vector< double >", &_nu_daughters_E);

  myTTree->Branch("event", &_event, "event/i");
  myTTree->Branch("run", &_run, "run/i");
  myTTree->Branch("subrun", &_subrun, "subrun/i");

  myTTree->Branch("flash_passed", &_flash_passed, "flash_passed/i");
  myTTree->Branch("track_passed", &_track_passed, "track_passed/i");
  myTTree->Branch("shower_passed", &_shower_passed, "shower_passed/i");

  myTTree->Branch("reco_px", &_reco_px, "reco_px/d");
  myTTree->Branch("reco_py", &_reco_px, "reco_py/d");
  myTTree->Branch("reco_pz", &_reco_px, "reco_pz/d");

  myTTree->Branch("true_px", &_true_px, "true_px/d");
  myTTree->Branch("true_py", &_true_py, "true_py/d");
  myTTree->Branch("true_pz", &_true_pz, "true_pz/d");

  myTTree->Branch("shower_dir_x",  "std::vector< double >", &_shower_dir_x);
  myTTree->Branch("shower_dir_y",  "std::vector< double >", &_shower_dir_y);
  myTTree->Branch("shower_dir_z",  "std::vector< double >", &_shower_dir_z);

  myTTree->Branch("shower_theta",  "std::vector< double >", &_shower_theta);
  myTTree->Branch("shower_phi",  "std::vector< double >", &_shower_phi);

  myPOTTTree->Branch("run", &_run_sr, "run/i");
  myPOTTTree->Branch("subrun", &_subrun_sr, "subrun/i");
  myPOTTTree->Branch("pot", &_pot, "pot/d");


  this->reconfigure(pset);

}

lee::PandoraLEEAnalyzer::~PandoraLEEAnalyzer()
{

  //store output tree
  // myTFile->cd();
  // myTTree->Write("pandoratree");



  // myTFile->Close();


  std::cout << "End!" << std::endl;
}

double lee::PandoraLEEAnalyzer::distance(double a[3], double b[3]) {
  double d = 0;

  for (int i = 0; i < 3; i++) {
    d += pow((a[i] - b[i]), 2);
  }

  return sqrt(d);
}

art::Ptr<recob::Shower> lee::PandoraLEEAnalyzer::get_most_energetic_shower(std::vector< art::Ptr<recob::Shower> > &showers) {
  art::Ptr<recob::Shower> most_energetic_shower;

  double max_energy = std::numeric_limits<double>::lowest();
  for (auto const& shower : showers) {
    if (shower->Energy()[shower->best_plane()] > max_energy) {
      most_energetic_shower = shower;
      max_energy = shower->Energy()[shower->best_plane()];
    }
  }
  return most_energetic_shower;
}

art::Ptr<recob::Track> lee::PandoraLEEAnalyzer::get_longest_track(std::vector< art::Ptr<recob::Track> > &tracks) {
  art::Ptr<recob::Track> longest_track;

  double max_length = std::numeric_limits<double>::lowest();
  for (auto const& track : tracks) {
    try {
      std::cout << track << " length " << track->Length() << std::endl;
      if (track->Length() > max_length) {
        longest_track = track;
        max_length = track->Length();
      }
    } catch (...) {
      std::cout << "Error getting longest track " << track << std::endl;
    }
  }
  std::cout << "Longest track " << max_length << std::endl;
  return longest_track;
}

void lee::PandoraLEEAnalyzer::get_daughter_tracks( std::vector < size_t > pf_ids, const art::Event & evt, std::vector< art::Ptr<recob::Track> > &tracks) {
  art::InputTag pandoraNu_tag { "pandoraNu" };

  auto const& pfparticle_handle = evt.getValidHandle< std::vector< recob::PFParticle > >( pandoraNu_tag );

  art::FindOneP< recob::Track > track_per_pfpart(pfparticle_handle, evt, pandoraNu_tag);

  for (auto const& pf_id : pf_ids) {
    try {
      auto const& track_obj = track_per_pfpart.at(pf_id);
      tracks.push_back(track_obj);
    } catch (...) {
      std::cout << "Error getting the track" << std::endl;
    }
  }
}

void lee::PandoraLEEAnalyzer::get_daughter_showers(std::vector < size_t > pf_ids, const art::Event & evt, std::vector< art::Ptr<recob::Shower> > &showers) {
  art::InputTag pandoraNu_tag { "pandoraNu" };

  auto const& pfparticle_handle = evt.getValidHandle< std::vector< recob::PFParticle > >( pandoraNu_tag );

  art::FindOneP< recob::Shower > shower_per_pfpart(pfparticle_handle, evt, pandoraNu_tag);

  for (auto const& pf_id : pf_ids) {
    try {

      auto const& shower_obj = shower_per_pfpart.at(pf_id);
      showers.push_back(shower_obj);
    } catch (...) {
      std::cout << "Error getting the shower" << std::endl;
    }
  }

}

// CORRECT SHOWER DIRECTION THAT SOMETIMES IS INVERTED
int lee::PandoraLEEAnalyzer::correct_direction(size_t pfp_id, const art::Event & evt) {
  art::InputTag pandoraNu_tag { "pandoraNu" };

  auto const& pfparticle_handle = evt.getValidHandle< std::vector< recob::PFParticle > >( pandoraNu_tag );

  art::FindManyP<recob::SpacePoint > spcpnts_per_pfpart ( pfparticle_handle, evt, pandoraNu_tag );
  std::vector<art::Ptr < recob::SpacePoint > > spcpnts = spcpnts_per_pfpart.at(pfp_id);

  int direction = 1;

  if (spcpnts.size() > 0) {
    art::FindOneP< recob::Vertex > vertex_per_pfpart(pfparticle_handle, evt, pandoraNu_tag);
    auto const& vertex_obj = vertex_per_pfpart.at(pfp_id);
    double vertex_xyz[3];
    vertex_obj->XYZ(vertex_xyz);
    TVector3 start_vec(vertex_xyz[0],vertex_xyz[1],vertex_xyz[2]);

    art::FindOneP< recob::Shower > shower_per_pfpart(pfparticle_handle, evt, pandoraNu_tag);
    auto const& shower_obj = shower_per_pfpart.at(pfp_id);
    TVector3 shower_vec(shower_obj->Direction().X(),shower_obj->Direction().Y(),shower_obj->Direction().Z());

    TVector3 avg_spcpnt = average_position(spcpnts);

    TVector3 a;
    TVector3 b;
    a = shower_vec;
    b = avg_spcpnt - start_vec;
    double costheta = a.Dot(b)/(a.Mag()*b.Mag());
    direction = costheta >= 0 ? 1 : -1;
  }

  return direction;
}

TVector3 lee::PandoraLEEAnalyzer::average_position(std::vector<art::Ptr < recob::SpacePoint > > &spcpnts) {
  double avg_x = 0;
  double avg_y = 0;
  double avg_z = 0;

  for (auto &spcpnt: spcpnts) {
    auto spcpnt_xyz = spcpnt->XYZ();
    avg_x += spcpnt_xyz[0];
    avg_y += spcpnt_xyz[1];
    avg_z += spcpnt_xyz[2];
  }

  return TVector3(avg_x/spcpnts.size(), avg_y/spcpnts.size(), avg_z/spcpnts.size());

}

double lee::PandoraLEEAnalyzer::trackEnergy(const art::Ptr<recob::Track>& track, const art::Event & evt)
{
  art::InputTag pandoraNu_tag { "pandoraNu" };
  auto const& track_handle = evt.getValidHandle< std::vector< recob::Track > >( pandoraNu_tag );
  art::FindManyP<anab::Calorimetry> calo_track_ass(track_handle, evt, "pandoraNucalo");
  const std::vector<art::Ptr<anab::Calorimetry>> calos = calo_track_ass.at(track->ID());
  double E = 0;
  double Eapprox = 0;

  for (size_t ical = 0; ical < calos.size(); ++ical)
  {
    if (E != 0) continue;
    if (!calos[ical]) continue;
    if (!calos[ical]->PlaneID().isValid) continue;
    int planenum = calos[ical]->PlaneID().Plane;
    if (planenum < 0 || planenum > 2) continue;
    if (planenum != 2) continue;                           // Use informartion from collection plane only

    // Understand if the calo module flipped the track
    //double dqdx_start = (calos[ical]->dQdx())[0] + (calos[ical]->dQdx())[1] + (calos[ical]->dQdx())[2];
    //double dqdx_end   = (calos[ical]->dQdx())[calos[ical]->dQdx().size()-1] + (calos[ical]->dQdx())[calos[ical]->dQdx().size()-2] + (calos[ical]->dQdx())[calos[ical]->dQdx().size()-3];
    //bool caloFlippedTrack = dqdx_start < dqdx_end;

    double mean = 0;
    double dedx = 0;
    double prevresrange = 0;

    if (calos[ical]->ResidualRange()[0] > track->Length() / 2)
    {
      prevresrange = track->Length();
    }

    double currentresrange = 0;

    for (size_t iTrkHit = 0; iTrkHit < calos[ical]->dEdx().size(); ++iTrkHit)
    {
      dedx = calos[ical]->dEdx()[iTrkHit];
      currentresrange = calos[ical]->ResidualRange()[iTrkHit];
      if (dedx > 0 && dedx < 10)
      {
        //std::cout << dedx << "\t" << currentresrange << "\t"<< prevresrange<<std::endl;
        mean += dedx;
        E += dedx * abs(prevresrange - currentresrange);
        prevresrange = currentresrange;
      }
    }
    //std::cout << "Length: " << track->Length() << "and Energy approximation is " << mean/calos[ical]->dEdx().size()*track->Length()<< "MeV"<<std::endl;
    Eapprox = mean / calos[ical]->dEdx().size() * track->Length();
  }
  return Eapprox / 1000; // convert to GeV
}


void lee::PandoraLEEAnalyzer::measure_energy(size_t ipf, const art::Event & evt, double & energy) {

  art::InputTag pandoraNu_tag { "pandoraNu" };

  auto const& pfparticle_handle = evt.getValidHandle< std::vector< recob::PFParticle > >( pandoraNu_tag );
  auto const& pfparticles(*pfparticle_handle);

  art::FindManyP<recob::Shower > showers_per_pfparticle ( pfparticle_handle, evt, pandoraNu_tag );
  std::vector<art::Ptr<recob::Shower>> showers = showers_per_pfparticle.at(ipf);

  for (size_t ish = 0; ish < showers.size(); ish++) {
    if (showers[ish]->Energy()[showers[ish]->best_plane()] > 0) {
      energy += showers[ish]->Energy()[showers[ish]->best_plane()];
    }
  }

  art::FindManyP<recob::Track > tracks_per_pfparticle ( pfparticle_handle, evt, pandoraNu_tag );
  std::vector<art::Ptr<recob::Track>> tracks = tracks_per_pfparticle.at(ipf);

  for (size_t itr = 0; itr < tracks.size(); itr++) {
    if (trackEnergy(tracks[itr], evt) > 0) {
      energy += trackEnergy(tracks[itr], evt);
    }
  }

  for (auto const& pfdaughter : pfparticles[ipf].Daughters()) {
    measure_energy(pfdaughter, evt, energy);
  }
}

size_t lee::PandoraLEEAnalyzer::choose_candidate(std::vector<size_t> & candidates, const art::Event & evt) {

  size_t chosen_candidate = 0;
  double most_z = -1;
  double longest_track_dir;

  for (auto const& ic : candidates) {
    std::vector<art::Ptr<recob::Track>> nu_tracks;
    std::vector< size_t > pfp_tracks_id = fElectronEventSelectionAlg.get_pfp_id_tracks_from_primary().at(ic);
    get_daughter_tracks(pfp_tracks_id, evt, nu_tracks);
    longest_track_dir = get_longest_track(nu_tracks)->StartDirection().Z();

    if (longest_track_dir > most_z) {
      chosen_candidate = ic;
      most_z = longest_track_dir;
    }

  }

  return chosen_candidate;

}


bool lee::PandoraLEEAnalyzer::is_dirt(double x[3]) const
{
  art::ServiceHandle<geo::Geometry> geo;
  double bnd[6] = {0., 2.*geo->DetHalfWidth(), -geo->DetHalfHeight(), geo->DetHalfHeight(), 0., geo->DetLength()};

  bool is_x = x[0] > bnd[0] && x[0] < bnd[1];
  bool is_y = x[1] > bnd[2] && x[1] < bnd[3];
  bool is_z = x[2] > bnd[4] && x[2] < bnd[5];
  return !(is_x && is_y && is_z);
}


void lee::PandoraLEEAnalyzer::endSubRun(const art::SubRun& sr)
{
  art::InputTag fPOTModuleLabel { "generator" };

  _run_sr = sr.run();
  _subrun_sr = sr.subRun();

  art::Handle< sumdata::POTSummary > potListHandle;
  if (sr.getByLabel(fPOTModuleLabel, potListHandle))
    _pot = potListHandle->totpot;
  else
    _pot = 0.;

  myPOTTTree->Fill();

}
void lee::PandoraLEEAnalyzer::clear() {
  _shower_dir_x.clear();
  _shower_dir_y.clear();
  _shower_dir_z.clear();

  _shower_theta.clear();
  _shower_phi.clear();

  _reco_px = std::numeric_limits<double>::lowest();
  _reco_py = std::numeric_limits<double>::lowest();
  _reco_pz = std::numeric_limits<double>::lowest();
  _true_px = std::numeric_limits<double>::lowest();
  _true_py = std::numeric_limits<double>::lowest();
  _true_pz = std::numeric_limits<double>::lowest();

  _flash_passed = 0;
  _track_passed = 0;
  _shower_passed = 0;
  _energy = std::numeric_limits<double>::lowest();
  _track_dir_z = std::numeric_limits<double>::lowest();
  _track_length = std::numeric_limits<double>::lowest();
  _true_nu_is_fiducial = std::numeric_limits<int>::lowest();
  _nu_energy = std::numeric_limits<double>::lowest();

  _n_tracks = std::numeric_limits<int>::lowest();
  _n_showers = std::numeric_limits<int>::lowest();

  _vx = std::numeric_limits<double>::lowest();
  _vy = std::numeric_limits<double>::lowest();
  _vz = std::numeric_limits<double>::lowest();

  _true_vx = std::numeric_limits<double>::lowest();
  _true_vy = std::numeric_limits<double>::lowest();
  _true_vz = std::numeric_limits<double>::lowest();

  _true_vx_sce = std::numeric_limits<double>::lowest();
  _true_vy_sce = std::numeric_limits<double>::lowest();
  _true_vz_sce = std::numeric_limits<double>::lowest();

  _nu_matched_tracks = std::numeric_limits<int>::lowest();
  _nu_matched_showers = std::numeric_limits<int>::lowest();

  _category = std::numeric_limits<int>::lowest();
  _run = std::numeric_limits<int>::lowest();
  _subrun = std::numeric_limits<int>::lowest();
  _event = std::numeric_limits<int>::lowest();
  _n_candidates = std::numeric_limits<int>::lowest();
  _n_true_nu = std::numeric_limits<int>::lowest();
  _run_sr = std::numeric_limits<int>::lowest();
  _subrun_sr = std::numeric_limits<int>::lowest();
  _n_matched = std::numeric_limits<int>::lowest();
  _pot = std::numeric_limits<double>::lowest();
  _event_passed = 0;
  _distance = std::numeric_limits<double>::lowest();

  _nu_daughters_E.clear();
  _nu_daughters_pdg.clear();

}

void lee::PandoraLEEAnalyzer::analyze(art::Event const & evt)
{
  clear();
  _run = evt.run();
  _subrun = evt.subRun();
  _event = evt.id().event();

  std::vector<size_t> nu_candidates;

  _event_passed = int(fElectronEventSelectionAlg.eventSelected(evt));
  std::string _hitfinderLabel = "pandoraCosmicHitRemoval";
  std::string _geantModuleLabel = "largeant";
  std::string _pfp_producer = "pandoraNu";
  std::string _spacepointLabel = "pandoraNu";

  lar_pandora::MCParticlesToPFParticles matchedParticles;    // This is a map: MCParticle to matched PFParticle
  lar_pandora::MCParticlesToHits        matchedParticleHits;
  if (_event_passed) {


    // --- Do the matching
    fElectronEventSelectionAlg.GetRecoToTrueMatches(evt, _pfp_producer, _spacepointLabel, _geantModuleLabel, _hitfinderLabel, matchedParticles, matchedParticleHits);


    for (auto & inu : fElectronEventSelectionAlg.get_primary_indexes()) {
      if (fElectronEventSelectionAlg.get_neutrino_candidate_passed().at(inu)) {
        nu_candidates.push_back(inu);
      }
    }
    std::cout << "EVENT PASSED" << std::endl;
  } else {
    std::cout << "EVENT NOT PASSED" << std::endl;

  }
  _n_candidates = nu_candidates.size();

  //do the analysis
  art::InputTag pandoraNu_tag { "pandoraNu" };
  art::InputTag generator_tag { "generator" };


  _category = 0;
  double true_neutrino_vertex[3];

  if (!evt.isRealData()) {
    auto const& generator_handle = evt.getValidHandle< std::vector< simb::MCTruth > >( generator_tag );
    auto const& generator(*generator_handle);
    _n_true_nu = generator.size();
    _true_nu_is_fiducial = 0;
    std::vector<simb::MCParticle> nu_mcparticles;

    if (generator.size() > 0) {
      _nu_energy = generator[0].GetNeutrino().Nu().E();
      int ccnc = generator[0].GetNeutrino().CCNC();
      if (ccnc == 1) {
        _category = k_nc;
      }

      true_neutrino_vertex[0] = generator[0].GetNeutrino().Nu().Vx();
      true_neutrino_vertex[1] = generator[0].GetNeutrino().Nu().Vy();
      true_neutrino_vertex[2] = generator[0].GetNeutrino().Nu().Vz();
      _true_vx = true_neutrino_vertex[0];
      _true_vy = true_neutrino_vertex[1];
      _true_vz = true_neutrino_vertex[2];
      _true_nu_is_fiducial = int(fElectronEventSelectionAlg.is_fiducial(true_neutrino_vertex));

      SpaceChargeMicroBooNE SCE = SpaceChargeMicroBooNE("SCEoffsets_MicroBooNE_E273.root");
      _true_vx_sce = _true_vx-SCE.GetPosOffsets(_true_vx, _true_vy, _true_vz)[0]+0.7;
      _true_vy_sce = _true_vy+SCE.GetPosOffsets(_true_vx, _true_vy, _true_vz)[1];
      _true_vz_sce = _true_vz+SCE.GetPosOffsets(_true_vx, _true_vy, _true_vz)[2];

      if (is_dirt(true_neutrino_vertex)) {
        _category = k_dirt;
      }


      for (int i = 0; i < generator[0].NParticles(); i++) {
        if (generator[0].Origin() == 1) {
          nu_mcparticles.push_back(generator[0].GetParticle(i));
        }
      }
    } else {
       _category = k_cosmic;
      _nu_energy = std::numeric_limits<double>::lowest();
    }

    int protons = 0;
    int electrons = 0;
    int muons = 0;


    // TODO: STORE PDG AND ENERGY OF EVERY NU_MCPARTICLE
    for (auto& mcparticle : nu_mcparticles) {
      if (mcparticle.Process() == "primary" and mcparticle.T() != 0 and mcparticle.StatusCode() == 1) {

        _nu_daughters_E.push_back(mcparticle.E());
        _nu_daughters_pdg.push_back(mcparticle.PdgCode());

        switch (mcparticle.PdgCode())
        {
        case (abs(2212)):
          protons++;
          break;

        case (abs(11)):
          electrons++;
          break;

        case (abs(13)):
          muons++;
          break;
        }

      }
    }

    if (_category != k_cosmic && _category != k_dirt && _category != k_nc) {
      if (protons != 0 && electrons != 0) {
        _category = k_nu_e;
      } else if (protons != 0 && muons != 0) {
        _category = k_nu_mu;
      }
    }
  } else {
    _category = k_data;
  }

  std::cout << "True neutrinos " << _n_true_nu << std::endl;
  std::cout << "Nu energy " << _nu_energy << std::endl;

  _energy = std::numeric_limits<double>::lowest();

  for (auto & i_primary : fElectronEventSelectionAlg.get_primary_indexes() ) {
    if (fElectronEventSelectionAlg.get_op_flash_indexes().at(i_primary) != -1) {
      _flash_passed = 1;
      if (fElectronEventSelectionAlg.get_n_showers().at(i_primary) != 0) {
        _shower_passed = 1;
        if (fElectronEventSelectionAlg.get_n_tracks().at(i_primary) != 0) {
          _track_passed = 1;
        }
      }
    }
  }

  if (_event_passed) {
    auto const& pfparticle_handle = evt.getValidHandle< std::vector< recob::PFParticle > >( pandoraNu_tag );
    //auto const& pfparticles(*pfparticle_handle);

    std::cout << "Before choose_candidate index " << std::endl;

    size_t ipf_candidate = choose_candidate(nu_candidates, evt);
    _energy = 0;
    std::cout << "Number of candidates " << nu_candidates.size() << std::endl;
    std::cout << "Candidate index " << ipf_candidate << std::endl;
    measure_energy(ipf_candidate, evt, _energy);
    std::cout << "Energy " << _energy << std::endl;

    art::FindOneP< recob::Vertex > vertex_per_pfpart(pfparticle_handle, evt, pandoraNu_tag);
    auto const& vertex_obj = vertex_per_pfpart.at(ipf_candidate);

    std::cout << "After vertex" << std::endl;

    double reco_neutrino_vertex[3];
    vertex_obj->XYZ(reco_neutrino_vertex);
    _vx = reco_neutrino_vertex[0];
    _vy = reco_neutrino_vertex[1];
    _vz = reco_neutrino_vertex[2];


    if (_category != k_data) {
      TVector3 v_reco_vertex(_vx, _vy, _vz);
      TVector3 sce_true_vertex(_true_vx_sce, _true_vy_sce, _true_vz_sce);

      _distance = fElectronEventSelectionAlg.distance(v_reco_vertex, sce_true_vertex);
      if (_distance > 5) _category = k_cosmic;

    }


    std::cout << "Category " << _category << std::endl;

    std::vector<art::Ptr<recob::Track>> chosen_tracks;
    std::vector< size_t > pfp_tracks_id = fElectronEventSelectionAlg.get_pfp_id_tracks_from_primary().at(ipf_candidate);
    get_daughter_tracks(pfp_tracks_id, evt, chosen_tracks);
    _track_dir_z = get_longest_track(chosen_tracks)->StartDirection().Z();
    _track_length = get_longest_track(chosen_tracks)->Length();
    _n_tracks = fElectronEventSelectionAlg.get_n_tracks().at(ipf_candidate);


    std::vector<art::Ptr<recob::Shower>> chosen_showers;
    std::vector< size_t > pfp_showers_id = fElectronEventSelectionAlg.get_pfp_id_showers_from_primary().at(ipf_candidate);
    get_daughter_showers(pfp_tracks_id, evt, chosen_showers);

    for (auto &pf_id: pfp_showers_id) {

      int direction = correct_direction(pf_id, evt);
      std::cout << "Correct direction " << direction << std::endl;
      art::FindOneP< recob::Shower > shower_per_pfpart(pfparticle_handle, evt, pandoraNu_tag);
      auto const& shower_obj = shower_per_pfpart.at(pf_id);

      TVector3 correct_dir(direction*shower_obj->Direction().X(),direction*shower_obj->Direction().Y(),direction*shower_obj->Direction().Z());

      _shower_dir_x.push_back(correct_dir.X());
      _shower_dir_y.push_back(correct_dir.Y());
      _shower_dir_z.push_back(correct_dir.Z());

      _shower_phi.push_back(correct_dir.Phi());
      _shower_theta.push_back(correct_dir.Theta());

    }

    _n_showers = fElectronEventSelectionAlg.get_n_showers().at(ipf_candidate);


    std::cout << "Chosen neutrino " << ipf_candidate << std::endl;
    art::ServiceHandle<cheat::BackTracker> bt;

    std::vector< art::Ptr<recob::PFParticle> > neutrino_pf;
    std::vector< art::Ptr<recob::PFParticle> > cosmic_pf;

    for (lar_pandora::MCParticlesToPFParticles::const_iterator iter1 = matchedParticles.begin(), iterEnd1 = matchedParticles.end();
    iter1 != iterEnd1; ++iter1) {

      art::Ptr<simb::MCParticle>  mc_par = iter1->first;   // The MCParticle
      art::Ptr<recob::PFParticle> pf_par = iter1->second;  // The matched PFParticle

      const art::Ptr<simb::MCTruth> mc_truth = bt->TrackIDToMCTruth(mc_par->TrackId());

      if (mc_truth->Origin() == simb::kBeamNeutrino) {
        std::cout << "Matched neutrino" << std::endl;
        std::cout << "Pf PDG: " << pf_par->PdgCode() << " MC PDG: " << mc_par->PdgCode() << std::endl;
        neutrino_pf.push_back(pf_par);
      }

      if (mc_truth->Origin() == simb::kCosmicRay) {
        cosmic_pf.push_back(pf_par);
      }

    }

    _n_matched = neutrino_pf.size();

    _nu_matched_showers = 0;
    _nu_matched_tracks = 0;

    for (size_t ish = 0; ish < pfp_showers_id.size(); ish++) {
      bool cr_found = false;

      for (size_t ipf = 0; ipf < cosmic_pf.size(); ipf++ ) {
        if (pfp_showers_id[ish] == cosmic_pf[ipf].key()) cr_found = true;
      }

      for (size_t ipf = 0; ipf < neutrino_pf.size(); ipf++ ) {
        if (pfp_showers_id[ish] == neutrino_pf[ipf].key()) {
          _nu_matched_showers++;
        }
      }

      std::cout << "Shower PFP " << pfp_showers_id[ish] << std::endl;
      std::cout << "Neutrino? " << _nu_matched_showers << std::endl;
      std::cout << "Cosmic? " << cr_found << std::endl;

    }

    for (size_t itr = 0; itr < pfp_tracks_id.size(); itr++) {
      bool cr_found = false;

      for (size_t ipf = 0; ipf < cosmic_pf.size(); ipf++ ) {
        if (pfp_tracks_id[itr] == cosmic_pf[ipf].key()) cr_found = true;
      }

      for (size_t ipf = 0; ipf < neutrino_pf.size(); ipf++ ) {
        if (pfp_tracks_id[itr] == neutrino_pf[ipf].key()) {
          _nu_matched_tracks++;
        }
      }


      std::cout << "Track PFP " << pfp_tracks_id[itr] << std::endl;
      std::cout << "Neutrino? " << _nu_matched_tracks << std::endl;
      std::cout << "Cosmic? " << cr_found << std::endl;

    }

    std::cout << "Matched particles " << neutrino_pf.size() << " Selected particles " << _nu_matched_showers+_nu_matched_tracks << std::endl;
    bool perfect_event = (_n_matched == _nu_matched_showers+_nu_matched_tracks) && _nu_matched_tracks == _n_tracks && _nu_matched_showers == _n_showers;
    std::cout << "Is perfect " << perfect_event << std::endl;
  }


  myTTree->Fill();
  std::cout << "END ANALYZER" << std::endl;

} // end analyze function

//------------------------------------------------------------------------------------------------------------------------------------


void lee::PandoraLEEAnalyzer::reconfigure(fhicl::ParameterSet const & pset)
{

  //TODO: add an external fcl file to change configuration
  //add what you want to read, and default values of your labels etc. example:
  //  m_particleLabel = pset.get<std::string>("PFParticleModule","pandoraNu");
  fElectronEventSelectionAlg.reconfigure(pset.get<fhicl::ParameterSet>("ElectronSelectionAlg"));

  m_printDebug = pset.get<bool>("PrintDebug", false);
  m_trackLength = pset.get<int>("trackLength", 100);

  m_fidvolXstart = pset.get<double>("fidvolXstart", 10);
  m_fidvolXend = pset.get<double>("fidvolXstart", 10);

  m_fidvolYstart = pset.get<double>("fidvolYstart", 20);
  m_fidvolYend = pset.get<double>("fidvolYend", 20);

  m_fidvolZstart = pset.get<double>("fidvolZstart", 10);
  m_fidvolZend = pset.get<double>("fidvolZend", 50);
}

//---------------------------------------------------------------------------------------------------------------------------
//add other functions here

DEFINE_ART_MODULE(lee::PandoraLEEAnalyzer)
